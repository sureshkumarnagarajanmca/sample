var //Mongoose = require('mongoose'),
Emmitable = require('../components/EmmitableObject.js'),
    CONSTANTS_EVENT,
    Logger, uuid = require('node-uuid');

CONSTANTS_EVENT = {
    FIND: {
        FOUND: 'RecordsFound',
        NOTFOUND: 'RecordsNotFound',
        ERROR: 'RecordFindError'
    },
    UPDATE: {
        SUCCESS: 'RecordUpdated',
        FAILURE: 'RecordNotUpdated',
        ERROR: 'RecordUpdateError'

    },
    CREATE: {
        SUCCESS: 'RecordCreated',
        ERROR: 'RecordCreateError',
        DUPLICATE: 'RecordAlreadyExists'
    },
    REMOVE: {
        SUCCESS: 'RecordsDeleted',
        ERROR: 'RecordDeletionError'
    }
};

Logger = console;
/**
 * This represents non-tenant Model abstraction
 *
 * @param contextProvider type Interface
 */
function AbstractModel(modelName, eventMap, middleWare, contextProvider) {
    var _modelName, _eventMap, _modelInst, _middleWare, _contextProvider,
        _modelProvider;

    _modelInst = this;
    _modelName = modelName;
    _eventMap = eventMap || {};
    _middleWare = middleWare || {};

    _contextProvider = contextProvider;
    /*    
    if(!_modelName){
        throw new Error('Model Name Required');
    }        
    */
    if (_modelInst.constructor === AbstractModel) {
        throw new Error("AbstractError , cannot be instantiated"); // To prevent the usage ::: new AbstractBean(state,helpers);
    }

    _modelInst.setModelProvider = function(modelProvider) {
        _modelProvider = modelProvider;
    };

    _modelInst.getModel = function(modelName) {
        if (!_modelProvider) {
            throw new Error('no model provider');
        }
        //Logger.info('getModel of abstractModel');        
        return _modelProvider.getModel(_modelName || modelName);
    };

    _modelInst.getEventName = function(defaultEventName, context) {
        var _eventName, _eventMapDefaultEventName;

        _eventMapDefaultEventName = _eventMap[defaultEventName];

        if (!context) {
            _eventName = _eventMapDefaultEventName || undefined;
            if (_eventName) {
                return _eventName;
            }
            return defaultEventName;
        }

        _eventName = _eventMap[context] ? _eventMap[context][defaultEventName] : defaultEventName;

        return _eventName;
    };

    _modelInst.getEventMiddleware = function(eventName, context) {
        //Logger.info('AbstractModel:getEventMiddleware - get eventMiddleware for eventName %s and context %s' , eventName,context);
        //Logger.info(_middleWare);
        if (!eventName || !context) {
            return undefined;
        }

        return _middleWare[context] && _middleWare[context][eventName];
    };
}

AbstractModel.prototype = Object.create(Emmitable.prototype);

AbstractModel.prototype.emit_1 = AbstractModel.prototype.emit;

AbstractModel.prototype.emit = function(eventName, context, eventData) {
    //console.log("emit of abstractmodel " + eventName);
    var _modelInst, _eventName, _eventMiddleware, _mWareProcessedData, _processedData, _context;

    //Logger.info("context %j",context);
    _modelInst = this;
    /*
        Temp FIX : byPass the whole process for the events generated by the EventEmitter instances as part of its internal processing
    */

    if (eventName === 'newListener') {
        _modelInst.emit_1(eventName, context);
        return;
    }

    _processedData = eventData;

    if (context && context.context) {
        _context = context.context;
        _eventMiddleware = _modelInst.getEventMiddleware(eventName, _context);
    }

    if (_eventMiddleware) {
        _mWareProcessedData = _eventMiddleware(eventData, context);
        eventName = _mWareProcessedData.overrideEvent || eventName;
        context.context = _mWareProcessedData.context || _context;
        _processedData = _mWareProcessedData.processedData || _processedData;
    }

    _eventName = _modelInst.getEventName(eventName, _context) || eventName;
    _modelInst.emit_1(_eventName, _processedData);
};

/**
 * This method
 *
 * @param    rec- Object literal representing the record to be inserted
 *
 *
 * @emits   RecordCreated
 *
 *          RecordsNotCreated
 *
 *          RecordCreateError
 *
 */
AbstractModel.prototype.createRecord = function(rec, context) {
    var _scope = this,
        _modelInst = this.getModel();

    function createRecord(rec) {

        function onCreateReturn(createErr, rec) {
            if (createErr) {
                Logger.log('Create Record Error - %j', createErr);
                _scope.emit('RecordCreateError', context, createErr);
                return;
            }
            _scope.emit('RecordCreated', context, rec);
        }

        if (!Array.isArray(rec)) {
            _modelInst.create(rec, onCreateReturn);
            return;
        }

        rec.push(onCreateReturn);
        _modelInst.create.apply(_modelInst, rec);
    }
    if (context && context.ensureNoDuplicacy) {
        _modelInst.findOne(context.findQuery, function(findErr, dbRec) {
            if (dbRec) {
                _scope.emit('RecordAlreadyExists', context, dbRec);
                return;
            }
            createRecord(rec);
        });
        return;
    }
    createRecord(rec);
};

/**
 * This method matches users matching the condition
 *
 * @param    matchCond - Object literal containing match property and
 *                          possible match values.
 *
 * @param   coloms  -   Object literal representing coloms to retrieve
 *
 * @emits   RecordsFound
 *
 *          RecordsNotFound
 *
 *          RecordFindError
 *
 */
AbstractModel.prototype.findRecordBy = function(matchCond, coloms, options, context) {
    //Logger.info("context find %j",context);
    //Logger.info("match cond %j",matchCond);
    var _scope = this,
        _modelInst = this.getModel(),
        _coloms = coloms || {};

    _modelInst.find(matchCond, _coloms, options, function(findErr, recs) {

        if (findErr) {
            Logger.error('AbstractModel:findRecordBy:modelInst-Callback - find Error %s', findErr);
            return _scope.emit('RecordFindError', context, findErr);
        }
        if (recs && recs.length) {
            return _scope.emit('RecordsFound', context, recs);
        } else {
            return _scope.emit('RecordsNotFound', context);
        }
    });
    //Logger.info('AbstractModel:findRecordBy - Exit');
};

/**
 * This method updates record
 *
 * @param    matchCond - Object literal containing match property and
 *                          possible match values.
 * @param
 *           updateSet - Object literal containing properties to update
 *
 * @emits  RecordUpdated
 *
 *         RecordNotUpdated
 *
 *         RecordUpdateError
 *
 */
AbstractModel.prototype.updateRecord = function(matchCond, update, context, updateOpts) {
    var _scope = this,
        _modelInst = this.getModel(),
        _updateOpts = updateOpts || {};
    _modelInst.update(matchCond, update, _updateOpts, function(updateErr, numAffected) {
        if (updateErr) {
            Logger.error('AbstractModel:updateRecord %s', updateErr);
            return _scope.emit('RecordUpdateError', context, updateErr);
        }
        if (numAffected > 0) {
            return _scope.emit('RecordUpdated', context, numAffected);
        } else {
            return _scope.emit('RecordNotUpdated', context);
        }
    });
};

/**
 * This Method deletes document
 *
 * @param {Object} matchCond Object literal containing match property
 *                              and possible match values
 * @param {Object} context Object literal containing the context in which
 *                          delete command is being called
 *
 * @emits
 *      RecordsDeleted
 *      RecordDeletionError
 */
AbstractModel.prototype.deleteRecord = function(matchCond, context) {
    var _scope = this,
        _modelInst = this.getModel();

    _modelInst.remove(matchCond, function(removeErr) {
        if (removeErr) {
            Logger.error('AbstractModel:deleteRecord %s', removeErr);
            return _scope.emit('RecordDeletionError', context, removeErr);
        }
        return _scope.emit('RecordsDeleted', context);
    });
};

/*
* to generate mongodb object id
*/
AbstractModel.prototype.generateObjectId = function() {
    return uuid.v4(); 
};


// Exports
module.exports = {
    AbstractModel: AbstractModel,
    CONSTANTS_EVENT: CONSTANTS_EVENT
};

